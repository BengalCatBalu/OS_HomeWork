# Отчет о программе для определения глубины рекурсии символьных связей при открытии файлов

## Задание

Цель данного задания - написать программу на языке C, которая определяет глубину рекурсии символьных связей при открытии файлов. Предлагается следующий алгоритм решения:

1. При запуске программы создается регулярный файл с именем "a".
2. Затем создается символьная связь с именем, например, "aa", на файл "a" и делается попытка открыть файл "aa".
3. Если открытие файла "aa" удалось, создается символьная связь с именем, например, "ab", на файл "aa" и делается попытка открыть файл "ab".
4. Процесс продолжается, пока открыть файл не удастся. Это означает, что достигнута глубина рекурсии (количество допустимых символьных связей) при открытии файла.
5. Значение глубины рекурсии выводится на экран.

Рекомендуется создавать все файлы в отдельной директории, чтобы в случае ошибки можно было легко удалить большое количество образовавшихся файлов. Также необходимо проверять возвращаемые значения из системных вызовов и своевременно закрывать файлы.

## Решение

Для реализации данного задания была разработана программа на языке C.

### Программа для определения глубины рекурсии символьных связей (symbolic_recursion.c)

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>

#define MAX_DEPTH 100

int main() {
    const char* base_file = "a";
    const char* link_format = "%c%c";
    char link_name[MAX_DEPTH + 1];
    char next_link_name[MAX_DEPTH + 1];
    int depth = 0;
    FILE* file;

    // Создание директории для файлов
    if (mkdir("files", 0777) == -1) {
        perror("mkdir");
        exit(1);
    }

    // Создание базового файла
    file = fopen("files/a", "w");
    if (file == NULL) {
        perror("fopen");
        exit(1);
    }
    fclose(file);

    // Генерация символьных связей и проверка открытия файлов
    while (depth < MAX_DEPTH) {
        snprintf(link_name, sizeof(link_name), link_format, 'a' + depth, 'a' + depth);
        snprintf(next_link_name, sizeof(next_link_name), link_format, 'a' + depth, 'a' + depth + 1);

        if (symlink(base_file, link_name) == -1) {
            perror("symlink");
            break;
        }

        file = fopen(next_link_name, "r");
        if (file == NULL) {
            printf("

Reached recursion depth: %d\n", depth);
            break;
        }
        fclose(file);

        depth++;
    }

    // Удаление созданных файлов и символьных связей
    for (int i = 0; i < depth; i++) {
        snprintf(link_name, sizeof(link_name), link_format, 'a' + i, 'a' + i);
        unlink(link_name);
    }

    // Удаление директории
    if (rmdir("files") == -1) {
        perror("rmdir");
        exit(1);
    }

    return 0;
}
```

## Описание работы программы

Программа создает директорию "files" с помощью функции `mkdir`, чтобы разместить все файлы в отдельной папке. Затем создается базовый файл "a" с помощью функции `fopen` и `fclose`.

Далее, программа генерирует символьные связи с помощью функции `symlink`. Каждая символьная связь имеет имя, состоящее из двух символов, например, "aa", "ab", "ac" и так далее. После создания символьной связи, программа пытается открыть файл, связанный с этой символьной связью, с помощью функции `fopen`. Если открытие файла не удалось, это означает, что достигнута глубина рекурсии. В этом случае, программа выводит значение глубины рекурсии на экран с помощью функции `printf` и прекращает генерацию символьных связей.

После выполнения всех операций, программа удаляет созданные файлы и символьные связи с помощью функции `unlink`. Затем директория "files" удаляется с помощью функции `rmdir`.

Для компиляции программы, необходимо использовать компилятор C, поддерживающий стандарт C99 или более позднюю версию. Программа может быть скомпилирована с помощью следующей команды:

```
gcc symbolic_recursion.c -o symbolic_recursion
```

После компиляции, программа может быть запущена из командной строки. Просто выполните следующую команду:

```
./symbolic_recursion
```

Приложение будет выполняться в соответствии с предложенным алгоритмом, создавая символьные связи и проверяя глубину рекурсии при открытии файлов. Значение глубины рекурсии будет выведено на экран. По завершении работы программы, все созданные файлы и символьные связи будут удалены.